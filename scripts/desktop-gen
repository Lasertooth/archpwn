#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (C) 2010 Francesco Piccinno
#
# Author: Francesco Piccinno <stack.box@gmail.com>
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

import os
import sys
import time
import tarfile
import tempfile

try:
    import json
except ImportError:
    print "You need python-json to be installed to run this script"
    sys.exit(-1)

from optparse import OptionParser

from pylibs.pkg import Pkg
from pylibs.utils import foreach_pkg, ConsoleP
from pylibs.archpwn import get_category,     \
                           get_categories,   \
                           get_directory,    \
                           iget_directories, \
                           GLOBAL_MAPPINGS

# Templates

DESKTOP_ENTRY = """#/usr/bin/env xdg-open
# Desktop-entry generated by desktop-gen

[Desktop Entry]
Version=1.0
Type=Application
Terminal=%(term)s
Icon=%(icon)s
Name=%(name)s
Exec=%(exec)s
Path=%(path)s
Comment=%(comment)s
Categories=%(categories)s
"""

LAUNCHER = """#!/bin/sh
# Simple launcher generated by desktop-gen
%(commands)s
"""

XDG_MENU = """<!DOCTYPE Menu PUBLIC "-//freedesktop//DTD Menu 1.0//EN"
 "http://www.freedesktop.org/standards/menu-spec/1.0/menu.dtd">

<Menu>
  <Name>%(name)s</Name>
  <Directory>%(directory)s</Directory>
  <DefaultAppDirs/>
  <DefaultDirectoryDirs/>
  <DefaultMergeDirs/>
  %(nested_menus)s
</Menu>
"""

MENU_ENTRY = """
  <Menu>
    <Name>%(name)s</Name>
    <Directory>%(directory)s</Directory>
    <Include><Category>%(category)s</Category></Include>
  </Menu>"""

DIRECTORY_ENTRY = """# Desktop-entry generated by desktop-gen
[Desktop Entry]
Version=1.0
Name=%(name)s
Icon=%(icon)s
Type=Directory
"""

def mode(self, samples):
  frequency = {}

  for x in samples:
     if x in frequency:
        frequency[x] += 1
     else:
        frequency[x] = 1

  mode = max(frequency.values())

  if mode == 1:
     return

  return [(x, mode) for x in frequency if (mode == frequency[x])]


class Generator(ConsoleP):
    def __init__(self, options, args):
        self.path = args[0]
        self.desktops = {}

        self.DESKTOP_PREFIX = options.desktop_dir
        self.DIRECTORIES_PREFIX = options.directories_dir
        self.MENU_PREFIX = options.menu_dir

        self.LAUNCHER_PREFIX = options.launcher_dir
        self.PENTEST_PREFIX = options.pentest_dir

        if not options.output_file:
            print 'You must specify an output file with -o'
            sys.exit(-1)

        self.is_squash = options.squash
        self.output_file = options.output_file

        ConsoleP.__init__(self, 'desktopgen')

        if os.getuid() != 0:
            self.warning('You should run this program as super-user or just using fakeroot')
            self.warning('Sleeping 3 seconds leaving you the time to read this message')
            time.sleep(3)

        self.load_settings(os.path.join(os.path.dirname(sys.argv[0]), \
                                        'desktop-entries.json'))
        self.destdir = tempfile.mkdtemp(prefix='archpwn')

        self.debug('Using %s as temporary directory' % self.destdir)
        self.create_dir_structure()

    def create_dir_structure(self):
        for dir in (self.DESKTOP_PREFIX,
                    self.DIRECTORIES_PREFIX,
                    self.MENU_PREFIX,
                    self.LAUNCHER_PREFIX,
                    self.PENTEST_PREFIX):
           os.makedirs(os.path.join(self.destdir, '.' + dir))

    def load_settings(self, fname):
        try:
            fjson = open(fname, 'r')
            contents = fjson.read()
            fjson.close()

            self.desktops = json.loads(contents)
        except:
            print "Unable to load desktop entries from %s file" % fname
            sys.exit(-1)

    def sanitize(self, txt):
        targets = ('-svn', '-git', '-hg', '-cvs')

        for target in targets:
            if txt.endswith(target):
                return txt[:-len(target)]

        return txt

    def add_generic_file(self, fname, contents, mode=None):
        if fname[0] == '/':
            fname = '.' + fname

        outfile = os.path.normpath(os.path.join(self.destdir, fname))
        fd = open(outfile, 'w')
        fd.write(contents)
        fd.close()

        if mode:
            os.system("chmod %d '%s'" % (mode, outfile))

        self.info('%s created' % fname)

    def add_desktop_entry(self, pkg, contents):
        self.add_generic_file(
            os.path.join(self.DESKTOP_PREFIX, \
                         '%s.desktop' % self.sanitize(pkg.name)),
            contents,
            755
        )

    def get_icon(self, term):
        # In order to assure that the package is a GUI program
        # we check the presence of term option in the dict

        return term and 'terminal' or 'file-manager'

    def check_valid_path(self, pkg, path):
        # Check if any package members has a correct path
        for mpath in pkg.members:
            if mpath.startswith(path):
                return path
        else:
            return path

        # If I'm here none of members has the same path. We
        # need to force the member's path by calculating dirname
        # of every pkg members and extracting the mode

        mpaths = map(os.path.dirname, pkg.members)
        valid = mode(mpath) or mpaths[0]

        self.warning('Path %s seems to be invalid for package %s' % pkg.name)
        self.warning('Assuming %s as a valid path' % valid)

        return valid

    def create_launcher_if_needed(self, pkg, execstr):
        # Simple checking
        cli_words = ('.sh', '.sudo', ';', ' -h', ' --help')

        for word in cli_words:
            if word in execstr:
                self.info('Creating launcher for %s' % pkg.name)

                contents = LAUNCHER % {
                    'commands' : execstr,
                }

                launcher_path = os.path.join(
                    self.LAUNCHER_PREFIX, '%s-launcher' % pkg.name
                )

                self.add_generic_file(launcher_path, contents, 755)

                return launcher_path

        return execstr

    def generate_from_json(self, pkg):
        try:
            pdict = self.desktops[pkg.name]
        except KeyError:
            pdict = self.desktops[self.sanitize(pkg.name)]

        term = pdict['term']
        path = pdict['path']
        exes = pdict['exec']

        path = self.check_valid_path(pkg, path)
        exes = self.create_launcher_if_needed(pkg, exes)

        entry = DESKTOP_ENTRY % {
            'name': pdict['name'],
            'exec': exes,
            'path': path,
            'term': term and 'true' or 'false',
            'icon': self.get_icon(term),
            'comment': pkg.desc,
            'categories': ';'.join(get_categories(pkg.groups)),
        }

        self.add_desktop_entry(pkg, entry)

    def autogenerate(self, pkg):
        # In order to auto-generate the desktop file we need to know
        # if the package is a GUI program or not. To achieve this we
        # simply check depends array.

        term = True
        toolkits = ('qt', 'gtk', 'wx', 'fox', 'tk')

        for depend in pkg.depends:
            for toolkit in toolkits:
                if toolkit in depend:
                    term = False
                    break

        main_cat = get_directory(pkg.groups[0])
        path = os.path.join(self.PENTEST_PREFIX, main_cat, self.sanitize(pkg.name))
        exes = 'ls -lh;sudo -s'

        entry = DESKTOP_ENTRY % {
            'name': self.sanitize(pkg.name),
            'exec': exes,
            'path': path,
            'term': term and 'true' or 'false',
            'icon': self.get_icon(term),
            'comment': pkg.desc,
            'categories': ';'.join(get_categories(pkg.groups)),
        }

        self.add_desktop_entry(pkg, entry)

    def symlink(self, orig, destdir):
        cwd = os.getcwd()
        temp = os.path.join(self.destdir, '.' + destdir)

        os.makedirs(temp)
        os.chdir(temp)

        if isinstance(orig, (list, tuple)):
            for m in orig:
                self.info("   %s -> %s" % (m, destdir))
                os.system("ln -sf '%s' ." % m)
        else:
            self.info("   %s -> %s" % (orig, destdir))
            os.system("ln -sf '%s' ." % orig)

        os.chdir(cwd)

    def create_symlink(self, pkg):
        sname = self.sanitize(pkg.name)

        if len(pkg.members) == 1:
            member = pkg.members[0]
            self.info("Symlinking single %s binary for %s" % (member, pkg.name))

            for cat in iget_directories(pkg.groups):
                dest = os.path.join(self.PENTEST_PREFIX, cat, sname)
                self.symlink('/' + member, dest)

            return

        bin_cnt = 0
        share_cnt = 0
        bin_members = []

        for member in pkg.members:
            if member.startswith('usr/bin/') or  \
               member.startswith('usr/sbin/') or \
               member.startswith('bin/') or      \
               member.startswith('sbin/'):
                bin_cnt += 1
                bin_members.append('/' + member)
            elif member.startswith('usr/share/' + pkg.name + '/') or \
                 member.startswith('usr/share/' + sname + '/'):
                share_cnt += 1

        if share_cnt > bin_cnt:
            self.info("Symlinking /usr/share/%s directory for %s" % \
                      (sname, pkg.name))

            for cat in iget_directories(pkg.groups):
                dest = os.path.join(self.PENTEST_PREFIX, cat, sname)
                self.symlink('/usr/share/%s' % sname, dest)
        else:
            self.info("Symlinking all binaries for %s" % (pkg.name))

            for cat in iget_directories(pkg.groups):
                dest = os.path.join(self.PENTEST_PREFIX, cat, sname)
                self.symlink(bin_members, dest)

    def generate_menu(self):
        nested_menus = ''

        for group in sorted(GLOBAL_MAPPINGS.keys()):
            name = get_category(group)
            directory_name = 'archpwn-%s.directory' % get_directory(group)

            nested_menus += MENU_ENTRY % {
                'name': name,
                'directory': directory_name,
                'category': name,
            }

            contents = DIRECTORY_ENTRY % {
                'name': name,
                'icon': self.get_icon(True),
            }

            fname = os.path.join(self.DIRECTORIES_PREFIX, directory_name)
            self.add_generic_file(fname, contents)

        menu = XDG_MENU % {
            'name': 'ArchPwn',
            'directory': 'archpwn.directory',
            'nested_menus': nested_menus
        }

        fmenu = os.path.join(self.MENU_PREFIX, 'archpwn.menu')
        self.add_generic_file(fmenu, menu)

        self.info('Menu generation complete')

    def make_tarball(self):
        self.info('Generating tarball')

        tfd = tarfile.open(self.output_file, 'w:bz2')
        tfd.add(self.destdir, arcname='.', recursive=True)
        tfd.close()

        self.info('Tarball %s succesfully created' % self.output_file)

    def make_squash(self):
        self.info('Generating lzm file')

        paths = ''

        for dir in os.listdir(self.destdir):
            paths += '%s/%s ' % (self.destdir, dir)

        os.system(
            'mksquashfs %(paths)s %(output)s '
            '-keep-as-directory -noappend -all-root' % {
                'paths': paths,
                'output': self.output_file
        })

        self.info('Squashfs file %s succesfully created' % self.output_file)

    def run(self):
        self.generate_menu()

        for pkg_path in foreach_pkg(self.path):
            pkg = Pkg(pkg_path)

            if 'base' in pkg.groups:
                pkg.groups.remove('base')
            if 'archpwn' in pkg.groups:
                pkg.groups.remove('archpwn')
            if 'archpwn-modules' in pkg.groups:
                pkg.groups.remove('archpwn-modules')

            if not pkg.groups:
                continue

            self.create_symlink(pkg)

            if pkg.name in self.desktops or \
               self.sanitize(pkg.name) in self.desktops:
                self.generate_from_json(pkg)
            else:
                self.autogenerate(pkg)

        if self.is_squash:
            self.make_squash()
        else:
            self.make_tarball()

if __name__ == '__main__':
    parser = OptionParser(usage="%s <repodir>" % sys.argv[0])

    parser.add_option('-d', '--desktop-dir', dest='desktop_dir', default='/usr/share/applications/',
                      help='Directory where all .desktop files will be placed')
    parser.add_option('-D', '--directories-dir', dest='directories_dir', default='/usr/share/desktop-directories/',
                      help='Directory where all .directory files will be placed')
    parser.add_option('-m', '--menu-dir', dest='menu_dir', default='/etc/xdg/menus/',
                      help='Directory where the archpwn XDG menu will be created')
    parser.add_option('-l', '--launcher-dir', dest='launcher_dir', default='/usr/share/archpwn-launchers/',
                      help='Directory where all auxiliary launchers will be created')
    parser.add_option('-p', '--pentest-dir', dest='pentest_dir', default='/pentest',
                      help='Directory where all symlinks will be created')
    parser.add_option('-s', '--mksquash', dest='squash', default=False,
                      help='Use mksquashfs instead generating a tarball')
    parser.add_option('-o', '--output', dest='output_file',
                      help='Output file (Example shortcuts.tar.bz2 or shortcuts.lzm)')

    (options, args) = parser.parse_args()

    if len(args) != 1:
        parser.print_help()
        sys.exit(-1)
    else:
        Generator(options, args).run()
